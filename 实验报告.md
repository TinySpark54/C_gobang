# C语言五子棋程序实验报告
##  一、基本原理
* ### 极大极小化搜索


    short search(Point point ,int depth,bool isMachine,short miniMax) {
    
        if (depth>0)
        {
            short value=0;
            short temp;
            Point *choices = generate_choices();
            for (int i = 0; i < MAXBRANCHES; i++)
            {
                next_state(choices[i]);
                temp = search(choices[i],depth-1,!isMachine,miniMax);
                if (isMachine && temp > value)
                {
                    value = temp;
                }
                else if (!isMachine && temp < value)
                {
                    value = temp;
                }
                de_state(choices[i]);
            }
            return value;
        }
        return get_value();
    }

* ### 估值算法
        int evaluatePattern(int pattern[], int length, bool player)
        {
        int score = 0;
    
            for (int i = 0; i <= length - 5; i++)
            {
                int playerCount = 0;
                int opponentCount = 0;
    
                for (int j = 0; j < 5; j++)
                {
                    if (pattern[i + j] == player)
                    {
                        playerCount++;
                    }
                    else if (pattern[i + j] == !player)
                    {
                        opponentCount++;
                    }
                }
    
                // 只有一种棋子才能形成棋型
                if (opponentCount == 0)
                {
                    switch (playerCount)
                    {
                    case 5: score += 10000;
                        break; // 连五
                    case 4: score += 1000;
                        break; // 活四
                    case 3: score += 100;
                        break; // 活三
                    case 2: score += 10;
                        break; // 活二
                    case 1: score += 1;
                        break; // 活一
                    }
                }
                else if (playerCount == 0)
                {
                    switch (opponentCount)
                    {
                    case 5: score -= 10000;
                        break; // 对手连五
                    case 4: score -= 1000;
                        break; // 对手活四
                    case 3: score -= 100;
                        break; // 对手活三
                    case 2: score -= 10;
                        break; // 对手活二
                    }
                }
            }
    
            return score;
        }
    
        // 评估棋盘分数
        short get_value()
        {
            int score = 0;
    
            // 检查所有行
            for (int i = 0; i < BOARD_SIZE; i++)
            {
                int row[BOARD_SIZE];
                for (int j = 0; j < BOARD_SIZE; j++)
                {
                    row[j] = Board[i][j];
                }
                score += evaluatePattern(row, BOARD_SIZE, COMPUTER);
            }
    
            // 检查所有列
            for (int j = 0; j < BOARD_SIZE; j++)
            {
                int col[BOARD_SIZE];
                for (int i = 0; i < BOARD_SIZE; i++)
                {
                    col[i] = Board[i][j];
                }
                score += evaluatePattern(col, BOARD_SIZE, COMPUTER);
            }
    
            // 检查对角线（左上到右下）
            for (int i = 0; i < BOARD_SIZE; i++)
            {
                for (int j = 0; j < BOARD_SIZE; j++)
                {
                    int diag[BOARD_SIZE];
                    int length = 0;
                    for (int k = 0; i + k < BOARD_SIZE && j + k < BOARD_SIZE; k++)
                    {
                        diag[length++] = Board[i + k][j + k];
                    }
                    if (length >= 5)
                    {
                        score += evaluatePattern(diag, length, COMPUTER);
                    }
                }
            }
    
            // 检查对角线（右上到左下）
            for (int i = 0; i < BOARD_SIZE; i++)
            {
                for (int j = 0; j < BOARD_SIZE; j++)
                {
                    int diag[BOARD_SIZE];
                    int length = 0;
                    for (int k = 0; i + k < BOARD_SIZE && j - k >= 0; k++)
                    {
                        diag[length++] = Board[i + k][j - k];
                    }
                    if (length >= 5)
                    {
                        score += evaluatePattern(diag, length, COMPUTER);
                    }
                }
            }
    
            return score;
        }
    
* ### α-β剪枝
* ### 启发式搜索
## 二、实现与改进
* ### 整合估值算法